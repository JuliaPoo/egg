
#![allow(missing_docs,non_camel_case_types)]
use crate ::*;

pub fn get_proof_file_path() -> &'static str {
  "/tmp/egg_proof.txt"
}

define_language! {
  pub enum CoqSimpleLanguage {
    "&Z.min" = IDZDOTmin([Id; 2]),
    "&Init.Nat.add" = IDInitDOTNatDOTadd([Id; 2]),
    "&Z.opp" = IDZDOTopp([Id; 1]),
    "&Init.Nat.sub" = IDInitDOTNatDOTsub([Id; 2]),
    "&@word.opp" = IDATwordDOTopp([Id; 3]),
    "&Z.divide" = IDZDOTdivide([Id; 2]),
    "&Z.div" = IDZDOTdiv([Id; 2]),
    "&3" = ID3([Id; 0]),
    "&Z.mul" = IDZDOTmul([Id; 2]),
    "&@word.sru" = IDATwordDOTsru([Id; 4]),
    "&Z.to_nat" = IDZDOTto_nat([Id; 1]),
    "&@eq" = IDATeq([Id; 3]),
    "&Z.sub" = IDZDOTsub([Id; 2]),
    "&@List.skipn" = IDATListDOTskipn([Id; 3]),
    "&@word.unsigned" = IDATwordDOTunsigned([Id; 3]),
    "&Z.modulo" = IDZDOTmodulo([Id; 2]),
    "&@List.firstn" = IDATListDOTfirstn([Id; 3]),
    "&v" = IDv([Id; 0]),
    "&Z.gt" = IDZDOTgt([Id; 2]),
    "&2" = ID2([Id; 0]),
    "&O" = IDO([Id; 0]),
    "&64" = ID64([Id; 0]),
    "&@word.slu" = IDATwordDOTslu([Id; 4]),
    "&@Datatypes.length" = IDATDatatypesDOTlength([Id; 2]),
    "&right" = IDright([Id; 0]),
    "&S" = IDS([Id; 1]),
    "&left0" = IDleft0([Id; 0]),
    "&0" = ID0([Id; 0]),
    "&Z.of_nat" = IDZDOTof_nat([Id; 1]),
    "&@word.rep" = IDATwordDOTrep([Id; 2]),
    "&Init.Nat.min" = IDInitDOTNatDOTmin([Id; 2]),
    "&word" = IDword([Id; 0]),
    "&Z.le" = IDZDOTle([Id; 2]),
    "&and" = IDand([Id; 2]),
    "&Z.add" = IDZDOTadd([Id; 2]),
    "&Z.pow" = IDZDOTpow([Id; 2]),
    "&x" = IDx([Id; 0]),
    "&x1" = IDx1([Id; 0]),
    "&@nil" = IDATnil([Id; 1]),
    "&x2" = IDx2([Id; 0]),
    "&4" = ID4([Id; 0]),
    "&xs" = IDxs([Id; 0]),
    "&Z.max" = IDZDOTmax([Id; 2]),
    "&False" = IDFalse([Id; 0]),
    "&Z.lt" = IDZDOTlt([Id; 2]),
    "&@app" = IDATapp([Id; 3]),
    "&not" = IDnot([Id; 1]),
    "&1" = ID1([Id; 0]),
    "&@word.add" = IDATwordDOTadd([Id; 4]),
    "&Z" = IDZ([Id; 0]),
    "&8" = ID8([Id; 0]),
    "&@word.sub" = IDATwordDOTsub([Id; 4]),
    "&@word.of_Z" = IDATwordDOTof_Z([Id; 3]),
    "&halflen" = IDhalflen([Id; 0]),
    "&@cons" = IDATcons([Id; 3]),
    "&True" = IDTrue([Id; 0]),
  }
}

pub fn symbol_metadata(name : &str) -> Option<(usize,bool)> {
  let v = vec![
    ("&Z.min", (2,false)),
    ("&Init.Nat.add", (2,false)),
    ("&Z.opp", (1,false)),
    ("&Init.Nat.sub", (2,false)),
    ("&@word.opp", (3,false)),
    ("&Z.divide", (2,false)),
    ("&Z.div", (2,false)),
    ("&3", (0,true)),
    ("&Z.mul", (2,false)),
    ("&@word.sru", (4,false)),
    ("&Z.to_nat", (1,false)),
    ("&@eq", (3,false)),
    ("&Z.sub", (2,false)),
    ("&@List.skipn", (3,false)),
    ("&@word.unsigned", (3,false)),
    ("&Z.modulo", (2,false)),
    ("&@List.firstn", (3,false)),
    ("&v", (0,false)),
    ("&Z.gt", (2,false)),
    ("&2", (0,true)),
    ("&O", (0,true)),
    ("&64", (0,true)),
    ("&@word.slu", (4,false)),
    ("&@Datatypes.length", (2,false)),
    ("&right", (0,false)),
    ("&S", (1,true)),
    ("&left0", (0,false)),
    ("&0", (0,true)),
    ("&Z.of_nat", (1,false)),
    ("&@word.rep", (2,false)),
    ("&Init.Nat.min", (2,false)),
    ("&word", (0,false)),
    ("&Z.le", (2,false)),
    ("&and", (2,false)),
    ("&Z.add", (2,false)),
    ("&Z.pow", (2,false)),
    ("&x", (0,false)),
    ("&x1", (0,false)),
    ("&@nil", (1,true)),
    ("&x2", (0,false)),
    ("&4", (0,true)),
    ("&xs", (0,false)),
    ("&Z.max", (2,false)),
    ("&False", (0,false)),
    ("&Z.lt", (2,false)),
    ("&@app", (3,false)),
    ("&not", (1,false)),
    ("&1", (0,true)),
    ("&@word.add", (4,false)),
    ("&Z", (0,false)),
    ("&8", (0,true)),
    ("&@word.sub", (4,false)),
    ("&@word.of_Z", (3,false)),
    ("&halflen", (0,false)),
    ("&@cons", (3,true)),
    ("&True", (0,false)),
  ];
  let o = v.iter().find(|t| t.0 == name);
  match o {
    Some((_, n)) => { return Some(*n); }
    None => { return None; }
  }
}

pub fn make_rules() -> Vec<Rewrite<CoqSimpleLanguage, ()>> {
  let v  : Vec<Rewrite<CoqSimpleLanguage, ()>> = vec![
    rewrite!("H0"; "(&@word.unsigned &64 &word(&@word.sub &64 &word &right &left0))" => "(&Z.mul &8(&Z.of_nat(&@Datatypes.length(&@word.rep &64 &word)&xs)))"),
    rewrite!("length_rep"; "(&@word.unsigned &64 &word(&@word.sub &64 &word &x2 &x1))" => "(&Z.mul &8(&Z.of_nat(&@Datatypes.length(&@word.rep &64 &word)&x)))"),
    rewrite!("H3"; "(&@Datatypes.length(&@word.rep &64 &word)&x)" => "&v"),
    rewrite!("H4"; "&True" => "(&not(&@eq &Z(&@word.unsigned &64 &word(&@word.sub &64 &word &x2 &x1))&0))"),
    rewrite!("L_length_skipn"; "(&@Datatypes.length ?A(&@List.skipn ?A ?n ?xs))" => "(&Init.Nat.sub(&@Datatypes.length ?A ?xs)?n)"),
    rewrite!("L_firstn_length"; "(&@Datatypes.length ?A(&@List.firstn ?A ?n ?l))" => "(&Init.Nat.min ?n(&@Datatypes.length ?A ?l))"),
    rewrite!("L_app_length"; "(&@Datatypes.length ?A(&@app ?A ?l ?l'))" => "(&Init.Nat.add(&@Datatypes.length ?A ?l)(&@Datatypes.length ?A ?l'))"),
    rewrite!("L_length_cons"; "(&@Datatypes.length ?A(&@cons ?A ?x ?xs))" => "(&S(&@Datatypes.length ?A ?xs))"),
    rewrite!("L_length_nil"; "(&@Datatypes.length ?A(&@nil ?A))" => "&O"),
    rewrite!("wunsigned_sub"; "(&@word.unsigned &64 &word(&@word.sub &64 &word ?x ?y))" => "(&Z.modulo(&Z.sub(&@word.unsigned &64 &word ?x)(&@word.unsigned &64 &word ?y))(&Z.pow &2 &64))"),
    rewrite!("wunsigned_add"; "(&@word.unsigned &64 &word(&@word.add &64 &word ?x ?y))" => "(&Z.modulo(&Z.add(&@word.unsigned &64 &word ?x)(&@word.unsigned &64 &word ?y))(&Z.pow &2 &64))"),
    rewrite!("z_plus_mod_idemp_r"; "(&Z.modulo(&Z.add ?b(&Z.modulo ?a ?n))?n)" => "(&Z.modulo(&Z.add ?b ?a)?n)"),
    rewrite!("z_plus_mod_idemp_l"; "(&Z.modulo(&Z.add(&Z.modulo ?a ?n)?b)?n)" => "(&Z.modulo(&Z.add ?a ?b)?n)"),
    rewrite!("z_minus_mod_idemp_r"; "(&Z.modulo(&Z.sub ?a(&Z.modulo ?b ?n))?n)" => "(&Z.modulo(&Z.sub ?a ?b)?n)"),
    rewrite!("z_minus_mod_idemp_l"; "(&Z.modulo(&Z.sub(&Z.modulo ?a ?n)?b)?n)" => "(&Z.modulo(&Z.sub ?a ?b)?n)"),
    rewrite!("z_add_0_l"; "(&Z.add &0 ?n)" => "?n"),
    rewrite!("z_add_comm"; "(&Z.add ?n ?m)" => "(&Z.add ?m ?n)"),
    rewrite!("z_add_to_left_assoc"; "(&Z.add ?n(&Z.add ?m ?p))" => "(&Z.add(&Z.add ?n ?m)?p)"),
    rewrite!("z_add_to_right_assoc"; "(&Z.add(&Z.add ?n ?m)?p)" => "(&Z.add ?n(&Z.add ?m ?p))"),
    rewrite!("z_add_opp"; "(&Z.add ?n(&Z.opp ?n))" => "&0"),
    rewrite!("z_sub_def"; "(&Z.sub ?n ?m)" => "(&Z.add ?n(&Z.opp ?m))"),
    rewrite!("z_mul_0_l"; "(&Z.mul &0 ?n)" => "&0"),
    rewrite!("z_mul_comm"; "(&Z.mul ?n ?m)" => "(&Z.mul ?m ?n)"),
    rewrite!("z_mul_to_left_assoc"; "(&Z.mul ?n(&Z.mul ?m ?p))" => "(&Z.mul(&Z.mul ?n ?m)?p)"),
    rewrite!("z_mul_to_right_assoc"; "(&Z.mul(&Z.mul ?n ?m)?p)" => "(&Z.mul ?n(&Z.mul ?m ?p))"),
    rewrite!("z_mul_add_distr_l"; "(&Z.mul ?n(&Z.add ?m ?p))" => "(&Z.add(&Z.mul ?n ?m)(&Z.mul ?n ?p))"),
    rewrite!("z_mul_opp_r"; "(&Z.mul ?n(&Z.opp ?m))" => "(&Z.opp(&Z.mul ?n ?m))"),
    rewrite!("Nat2Z_inj_sub_max"; "(&Z.of_nat(&Init.Nat.sub ?n ?m))" => "(&Z.max &0(&Z.sub(&Z.of_nat ?n)(&Z.of_nat ?m)))"),
    rewrite!("Nat2Z_inj_succ"; "(&Z.of_nat(&S ?n))" => "(&Z.add(&Z.of_nat ?n)&1)"),
    rewrite!("z_of_nat_to_nat"; "(&Z.of_nat(&Z.to_nat ?x))" => "(&Z.max &0 ?x)"),
    coq_rewrite!("z_mul_max_distr_nonneg_l"; "?$hyp0 = &True = (&Z.le &0 ?p), ?$lhs = (&Z.mul ?p(&Z.max ?n ?m))" => "(&Z.max(&Z.mul ?p ?n)(&Z.mul ?p ?m))"),
    coq_rewrite!("z_mul_max_distr_nonpos_l"; "?$hyp0 = &True = (&Z.le ?p &0), ?$lhs = (&Z.mul ?p(&Z.max ?n ?m))" => "(&Z.min(&Z.mul ?p ?n)(&Z.mul ?p ?m))"),
    coq_rewrite!("z_mod_eq"; "?$hyp0 = &True = (&Z.gt ?b &0), ?$lhs = (&Z.modulo ?a ?b)" => "(&Z.sub ?a(&Z.mul(&Z.div ?a ?b)?b))"),
    rewrite!("z_opp_add_distr"; "(&Z.opp(&Z.add ?n ?m))" => "(&Z.add(&Z.opp ?n)(&Z.opp ?m))"),
    rewrite!("z_sub_def_bw"; "(&Z.add ?n(&Z.opp ?m))" => "(&Z.sub ?n ?m)"),
    rewrite!("wunsigned_sub_bw"; "(&Z.modulo(&Z.sub(&@word.unsigned &64 &word ?x)(&@word.unsigned &64 &word ?y))(&Z.pow &2 &64))" => "(&@word.unsigned &64 &word(&@word.sub &64 &word ?x ?y))"),
    rewrite!("wunsigned_add_bw"; "(&Z.modulo(&Z.add(&@word.unsigned &64 &word ?x)(&@word.unsigned &64 &word ?y))(&Z.pow &2 &64))" => "(&@word.unsigned &64 &word(&@word.add &64 &word ?x ?y))"),
    rewrite!("z_mul_sub_distr_l"; "(&Z.mul ?n(&Z.sub ?m ?p))" => "(&Z.sub(&Z.mul ?n ?m)(&Z.mul ?n ?p))"),
    coq_rewrite!("z_mod_small"; "?$hyp0 = &True = (&and(&Z.le &0 ?a)(&Z.lt ?a ?b)), ?$lhs = (&Z.modulo ?a ?b)" => "?a"),
    rewrite!("z_mod_plus_full"; "(&Z.modulo(&Z.add ?a(&Z.mul ?b ?c))?c)" => "(&Z.modulo ?a ?c)"),
    rewrite!("z_mult_mod_distr_r"; "(&Z.modulo(&Z.mul ?a ?c)(&Z.mul ?b ?c))" => "(&Z.mul(&Z.modulo ?a ?b)?c)"),
    rewrite!("z_mul_1_r"; "(&Z.mul ?n &1)" => "?n"),
    rewrite!("C11"; "&True" => "(&not(&@eq &Z &8 &0))"),
    rewrite!("C12"; "(&Z.pow &2 &64)" => "(&Z.mul(&Z.div(&Z.pow &2 &64)&8)&8)"),
    coq_rewrite!("z_explain_mod"; "?$trigger0 = (&Z.modulo ?a ?b), ?$lhs = ?a" => "(&Z.add(&Z.mul(&Z.div ?a ?b)?b)(&Z.modulo ?a ?b))"),
    rewrite!("z_factor_1_plus"; "(&Z.add ?n(&Z.mul ?n ?m))" => "(&Z.mul ?n(&Z.add &1 ?m))"),
    rewrite!("z_mul_add_distr_l_bw"; "(&Z.add(&Z.mul ?n ?m)(&Z.mul ?n ?p))" => "(&Z.mul ?n(&Z.add ?m ?p))"),
    rewrite!("z_mul_opp_r_bw"; "(&Z.opp(&Z.mul ?n ?m))" => "(&Z.mul ?n(&Z.opp ?m))"),
    coq_rewrite!("z_div_mult_full"; "?$hyp0 = &True = (&not(&@eq &Z ?b &0)), ?$lhs = (&Z.div(&Z.mul ?a ?b)?b)" => "?a"),
    rewrite!("halflen$def"; "&halflen" => "(&Z.div(&Z.mul &8(&Z.of_nat &v))(&Z.pow &2 &4))"),
    rewrite!("C1"; "&True" => "(&and(&Z.le &0 &8)(&Z.lt &8(&Z.pow &2 &64)))"),
    rewrite!("C2"; "&True" => "(&and(&Z.le &0 &3)(&Z.lt &3 &64))"),
    rewrite!("C3"; "&True" => "(&and(&Z.le &0 &4)(&Z.lt &4 &64))"),
    rewrite!("C4"; "&True" => "(&Z.le &0(&Z.pow &2 &3))"),
    rewrite!("C5"; "&True" => "(&Z.lt &0(&Z.pow &2 &4))"),
    rewrite!("C6"; "&True" => "(&Z.lt &0(&Z.pow &2 &64))"),
    rewrite!("C7"; "&True" => "(&Z.lt &0(&Z.pow &2 &3))"),
    rewrite!("C8"; "&True" => "(&Z.lt(&Z.pow &2 &3)(&Z.pow &2 &4))"),
    rewrite!("C9"; "(&Z.pow &2 &3)" => "&8"),
    rewrite!("C10"; "&True" => "(&Z.divide(&Z.pow &2 &3)(&Z.pow &2 &64))"),
    rewrite!("wadd_0_l"; "(&@word.add &64 &word(&@word.of_Z &64 &word &0)?x)" => "?x"),
    rewrite!("wadd_0_r"; "(&@word.add &64 &word ?x(&@word.of_Z &64 &word &0))" => "?x"),
    rewrite!("wadd_comm"; "(&@word.add &64 &word ?a ?b)" => "(&@word.add &64 &word ?b ?a)"),
    rewrite!("wadd_to_left_assoc"; "(&@word.add &64 &word ?a(&@word.add &64 &word ?b ?c))" => "(&@word.add &64 &word(&@word.add &64 &word ?a ?b)?c)"),
    rewrite!("wadd_to_right_assoc"; "(&@word.add &64 &word(&@word.add &64 &word ?a ?b)?c)" => "(&@word.add &64 &word ?a(&@word.add &64 &word ?b ?c))"),
    rewrite!("wadd_opp"; "(&@word.add &64 &word ?a(&@word.opp &64 &word ?a))" => "(&@word.of_Z &64 &word &0)"),
    rewrite!("wsub_def"; "(&@word.sub &64 &word ?a ?b)" => "(&@word.add &64 &word ?a(&@word.opp &64 &word ?b))"),
    coq_rewrite!("wunsigned_of_Z_nowrap"; "?$hyp0 = &True = (&and(&Z.le &0 ?x)(&Z.lt ?x(&Z.pow &2 &64))), ?$lhs = (&@word.unsigned &64 &word(&@word.of_Z &64 &word ?x))" => "?x"),
    coq_rewrite!("wunsigned_nonneg"; "?$trigger0 = (&@word.unsigned &64 &word ?x), ?$lhs = &True" => "(&Z.le &0(&@word.unsigned &64 &word ?x))"),
    coq_rewrite!("wunsigned_sru_to_div_pow2"; "?$hyp0 = &True = (&and(&Z.le &0 ?a)(&Z.lt ?a &64)), ?$lhs = (&@word.unsigned &64 &word(&@word.sru &64 &word ?x(&@word.of_Z &64 &word ?a)))" => "(&Z.div(&@word.unsigned &64 &word ?x)(&Z.pow &2 ?a))"),
    coq_rewrite!("wunsigned_slu_to_mul_pow2"; "?$hyp0 = &True = (&and(&Z.le &0 ?a)(&Z.lt ?a &64)), ?$lhs = (&@word.unsigned &64 &word(&@word.slu &64 &word ?x(&@word.of_Z &64 &word ?a)))" => "(&Z.modulo(&Z.mul(&@word.unsigned &64 &word ?x)(&Z.pow &2 ?a))(&Z.pow &2 &64))"),
    coq_rewrite!("Z_forget_mod_in_lt_l"; "?$hyp0 = &True = (&Z.le &0 ?a), ?$hyp1 = &True = (&Z.lt &0 ?m), ?$hyp2 = &True = (&Z.lt ?a ?b), ?$lhs = &True" => "(&Z.lt(&Z.modulo ?a ?m)?b)"),
    coq_rewrite!("z_mul_nonneg"; "?$hyp0 = &True = (&Z.le &0 ?e1), ?$hyp1 = &True = (&Z.le &0 ?e2), ?$trigger0 = (&Z.mul ?e1 ?e2), ?$lhs = &True" => "(&Z.le &0(&Z.mul ?e1 ?e2))"),
    coq_rewrite!("z_div_nonneg"; "?$hyp0 = &True = (&Z.le &0 ?a), ?$hyp1 = &True = (&Z.lt &0 ?b), ?$trigger0 = (&Z.div ?a ?b), ?$lhs = &True" => "(&Z.le &0(&Z.div ?a ?b))"),
    coq_rewrite!("z_div_mul_lt"; "?$hyp0 = &True = (&Z.lt &0 ?x), ?$hyp1 = &True = (&Z.lt &0 ?d1), ?$hyp2 = &True = (&Z.lt ?d1 ?d2), ?$lhs = &True" => "(&Z.lt(&Z.mul(&Z.div ?x ?d2)?d1)?x)"),
    coq_rewrite!("z_lt_from_le_and_neq"; "?$hyp0 = &True = (&Z.le ?x ?y), ?$hyp1 = &True = (&not(&@eq &Z ?x ?y)), ?$lhs = &True" => "(&Z.lt ?x ?y)"),
    coq_rewrite!("z_remove_inner_mod"; "?$hyp0 = &True = (&Z.lt &0 ?n), ?$hyp1 = &True = (&Z.lt &0 ?m), ?$hyp2 = &True = (&Z.divide ?n ?m), ?$lhs = (&Z.modulo(&Z.modulo ?a ?m)?n)" => "(&Z.modulo ?a ?n)"),
    rewrite!("z_mod_mult"; "(&Z.modulo(&Z.mul ?a ?b)?b)" => "&0"),
    rewrite!("H_eq_eq_sym"; "(&@eq ?A ?x ?y)" => "(&@eq ?A ?y ?x)"),
    rewrite!("H_eq_same_True"; "(&@eq ?A ?a ?a)" => "&True"),
  ];
  v
}

pub fn get_lemma_arity(name: &str) -> Option<usize> {
  let v = vec![
    ("H0", 0),
    ("length_rep", 0),
    ("H3", 0),
    ("H4", 0),
    ("L_length_skipn", 3),
    ("L_firstn_length", 3),
    ("L_app_length", 3),
    ("L_length_cons", 3),
    ("L_length_nil", 1),
    ("wunsigned_sub", 2),
    ("wunsigned_add", 2),
    ("z_plus_mod_idemp_r", 3),
    ("z_plus_mod_idemp_l", 3),
    ("z_minus_mod_idemp_r", 3),
    ("z_minus_mod_idemp_l", 3),
    ("z_add_0_l", 1),
    ("z_add_comm", 2),
    ("z_add_to_left_assoc", 3),
    ("z_add_to_right_assoc", 3),
    ("z_add_opp", 1),
    ("z_sub_def", 2),
    ("z_mul_0_l", 1),
    ("z_mul_comm", 2),
    ("z_mul_to_left_assoc", 3),
    ("z_mul_to_right_assoc", 3),
    ("z_mul_add_distr_l", 3),
    ("z_mul_opp_r", 2),
    ("Nat2Z_inj_sub_max", 2),
    ("Nat2Z_inj_succ", 1),
    ("z_of_nat_to_nat", 1),
    ("z_mul_max_distr_nonneg_l", 4),
    ("z_mul_max_distr_nonpos_l", 4),
    ("z_mod_eq", 3),
    ("z_opp_add_distr", 2),
    ("z_sub_def_bw", 2),
    ("wunsigned_sub_bw", 2),
    ("wunsigned_add_bw", 2),
    ("z_mul_sub_distr_l", 3),
    ("z_mod_small", 3),
    ("z_mod_plus_full", 3),
    ("z_mult_mod_distr_r", 3),
    ("z_mul_1_r", 1),
    ("C11", 0),
    ("C12", 0),
    ("z_explain_mod", 2),
    ("z_factor_1_plus", 2),
    ("z_mul_add_distr_l_bw", 3),
    ("z_mul_opp_r_bw", 2),
    ("z_div_mult_full", 3),
    ("halflen$def", 0),
    ("C1", 0),
    ("C2", 0),
    ("C3", 0),
    ("C4", 0),
    ("C5", 0),
    ("C6", 0),
    ("C7", 0),
    ("C8", 0),
    ("C9", 0),
    ("C10", 0),
    ("wadd_0_l", 1),
    ("wadd_0_r", 1),
    ("wadd_comm", 2),
    ("wadd_to_left_assoc", 3),
    ("wadd_to_right_assoc", 3),
    ("wadd_opp", 1),
    ("wsub_def", 2),
    ("wunsigned_of_Z_nowrap", 2),
    ("wunsigned_nonneg", 1),
    ("wunsigned_sru_to_div_pow2", 3),
    ("wunsigned_slu_to_mul_pow2", 3),
    ("Z_forget_mod_in_lt_l", 6),
    ("z_mul_nonneg", 4),
    ("z_div_nonneg", 4),
    ("z_div_mul_lt", 6),
    ("z_lt_from_le_and_neq", 4),
    ("z_remove_inner_mod", 6),
    ("z_mod_mult", 2),
    ("H_eq_eq_sym", 3),
    ("H_eq_same_True", 2),
  ];
  let o = v.iter().find(|t| t.0 == name);
  match o {
    Some((_, n)) => { return Some(*n); }
    None => { return None; }
  }
}

pub fn is_eq(name: &str) -> Option<bool> {
  let v = vec![
    ("H0", true),
    ("length_rep", true),
    ("H3", true),
    ("H4", false),
    ("L_length_skipn", true),
    ("L_firstn_length", true),
    ("L_app_length", true),
    ("L_length_cons", true),
    ("L_length_nil", true),
    ("wunsigned_sub", true),
    ("wunsigned_add", true),
    ("z_plus_mod_idemp_r", true),
    ("z_plus_mod_idemp_l", true),
    ("z_minus_mod_idemp_r", true),
    ("z_minus_mod_idemp_l", true),
    ("z_add_0_l", true),
    ("z_add_comm", true),
    ("z_add_to_left_assoc", true),
    ("z_add_to_right_assoc", true),
    ("z_add_opp", true),
    ("z_sub_def", true),
    ("z_mul_0_l", true),
    ("z_mul_comm", true),
    ("z_mul_to_left_assoc", true),
    ("z_mul_to_right_assoc", true),
    ("z_mul_add_distr_l", true),
    ("z_mul_opp_r", true),
    ("Nat2Z_inj_sub_max", true),
    ("Nat2Z_inj_succ", true),
    ("z_of_nat_to_nat", true),
    ("z_mul_max_distr_nonneg_l", true),
    ("z_mul_max_distr_nonpos_l", true),
    ("z_mod_eq", true),
    ("z_opp_add_distr", true),
    ("z_sub_def_bw", true),
    ("wunsigned_sub_bw", true),
    ("wunsigned_add_bw", true),
    ("z_mul_sub_distr_l", true),
    ("z_mod_small", true),
    ("z_mod_plus_full", true),
    ("z_mult_mod_distr_r", true),
    ("z_mul_1_r", true),
    ("C11", false),
    ("C12", true),
    ("z_explain_mod", true),
    ("z_factor_1_plus", true),
    ("z_mul_add_distr_l_bw", true),
    ("z_mul_opp_r_bw", true),
    ("z_div_mult_full", true),
    ("halflen$def", true),
    ("C1", false),
    ("C2", false),
    ("C3", false),
    ("C4", false),
    ("C5", false),
    ("C6", false),
    ("C7", false),
    ("C8", false),
    ("C9", true),
    ("C10", false),
    ("wadd_0_l", true),
    ("wadd_0_r", true),
    ("wadd_comm", true),
    ("wadd_to_left_assoc", true),
    ("wadd_to_right_assoc", true),
    ("wadd_opp", true),
    ("wsub_def", true),
    ("wunsigned_of_Z_nowrap", true),
    ("wunsigned_nonneg", false),
    ("wunsigned_sru_to_div_pow2", true),
    ("wunsigned_slu_to_mul_pow2", true),
    ("Z_forget_mod_in_lt_l", false),
    ("z_mul_nonneg", false),
    ("z_div_nonneg", false),
    ("z_div_mul_lt", false),
    ("z_lt_from_le_and_neq", false),
    ("z_remove_inner_mod", true),
    ("z_mod_mult", true),
    ("H_eq_eq_sym", true),
    ("H_eq_same_True", true),
  ];
  let o = v.iter().find(|t| t.0 == name);
  match o {
    Some((_, n)) => { return Some(*n); }
    None => { return None; }
  }
}

#[allow(unused_variables)]
pub fn run_simplifier(f_simplify : fn(&str, Vec<&str>, Ffn) -> (), f_prove : fn(&str, &str, Vec<&str>) -> ()) {
  let es = vec![
    "(&Z.lt(&Z.pow &2 &3)(&Z.pow &2 &4))",
    "(&Z.lt &0(&Z.pow &2 &64))",
    "(&Z.le &0(&Z.pow &2 &3))",
    "(&Z.div(&Z.mul &8(&Z.of_nat &v))(&Z.pow &2 &4))",
    "(&Z.lt &0(&Z.pow &2 &4))",
    "(&and(&Z.le &0 &3)(&Z.lt &3 &64))",
    "(&@word.of_Z &64 &word &0)",
    "&O",
    "&True",
    "(&@word.unsigned &64 &word(&@word.sub &64 &word &right &left0))",
    "(&Z.mul &8(&Z.of_nat(&@Datatypes.length(&@word.rep &64 &word)&x)))",
    "(&and(&Z.le &0 &8)(&Z.lt &8(&Z.pow &2 &64)))",
    "(&not(&@eq &Z &8 &0))",
    "(&Z.lt &0(&Z.pow &2 &3))",
    "(&Z.mul &8(&Z.of_nat(&@Datatypes.length(&@word.rep &64 &word)&xs)))",
    "(&Z.mul(&Z.div(&Z.pow &2 &64)&8)&8)",
    "(&@Datatypes.length(&@word.rep &64 &word)&x)",
    "(&Z.divide(&Z.pow &2 &3)(&Z.pow &2 &64))",
    "&8",
    "&v",
    "(&Z.pow &2 &64)",
    "&0",
    "(&@word.unsigned &64 &word(&@word.sub &64 &word &x2 &x1))",
    "(&and(&Z.le &0 &4)(&Z.lt &4 &64))",
    "&halflen",
    "(&not(&@eq &Z(&@word.unsigned &64 &word(&@word.sub &64 &word &x2 &x1))&0))",
    "(&Z.pow &2 &3)",
  ];
  let st : &str = "(&@eq &Z(&@word.unsigned &64 &word(&@word.sub &64 &word &x2(&@word.add &64 &word(&@word.add &64 &word &x1(&@word.slu &64 &word(&@word.sru &64 &word(&@word.sub &64 &word &x2 &x1)(&@word.of_Z &64 &word &4))(&@word.of_Z &64 &word &3)))(&@word.of_Z &64 &word &8))))(&Z.mul &8(&Z.of_nat(&@Datatypes.length(&@word.rep &64 &word)(&@List.skipn(&@word.rep &64 &word)(&S(&Z.to_nat(&Z.div(&@word.unsigned &64 &word(&@word.sub &64 &word(&@word.add &64 &word &x1(&@word.slu &64 &word(&@word.sru &64 &word(&@word.sub &64 &word &x2 &x1)(&@word.of_Z &64 &word &4))(&@word.of_Z &64 &word &3)))&x1))(&@word.unsigned &64 &word(&@word.of_Z &64 &word &8)))))&x)))))";
  f_simplify(st, es, 6);
}
